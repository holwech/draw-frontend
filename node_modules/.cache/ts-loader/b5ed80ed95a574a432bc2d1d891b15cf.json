{"remainingRequest":"/home/holwech/code/draw/node_modules/babel-loader/lib/index.js!/home/holwech/code/draw/node_modules/ts-loader/index.js??ref--13-2!/home/holwech/code/draw/src/draw/draw/SVGDraw.ts","dependencies":[{"path":"/home/holwech/code/draw/src/draw/draw/SVGDraw.ts","mtime":1552213879434},{"path":"/home/holwech/code/draw/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/holwech/code/draw/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/home/holwech/code/draw/node_modules/ts-loader/index.js","mtime":1540965372000}],"contextDependencies":[],"result":["import _classCallCheck from \"/home/holwech/code/draw/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/holwech/code/draw/node_modules/@babel/runtime/helpers/esm/createClass\";\nexport var SVGDraw =\n/*#__PURE__*/\nfunction () {\n  function SVGDraw(svgElement) {\n    _classCallCheck(this, SVGDraw);\n\n    this.path = document.createElementNS('http://www.w3.org/2000/svg', 'path');\n    this.pathStarted = false;\n    this.buffer = [];\n    this.svg = svgElement;\n  }\n\n  _createClass(SVGDraw, [{\n    key: \"clear\",\n    value: function clear() {\n      var lastChild = this.svg.lastChild;\n\n      while (lastChild) {\n        this.svg.removeChild(lastChild);\n        lastChild = this.svg.lastChild;\n      }\n    }\n  }, {\n    key: \"onPointerDown\",\n    value: function onPointerDown(point, style) {\n      this.pathStarted = true;\n      this.path = document.createElementNS('http://www.w3.org/2000/svg', 'path');\n      this.path.setAttribute('fill', 'none');\n      this.path.setAttribute('stroke', style.color);\n      this.path.setAttribute('stroke-width', String(style.width)); // Keeps stroke width constant, regardless of zoom\n      // this.path.setAttribute('vector-effect', 'non-scaling-stroke');\n\n      this.buffer = [];\n      this.appendToBuffer(point, style.bufferSize);\n      this.strPath = 'M' + point.x + ' ' + point.y;\n      this.path.setAttribute('d', this.strPath);\n      this.svg.appendChild(this.path);\n    }\n  }, {\n    key: \"onPointerMove\",\n    value: function onPointerMove(point, bufferSize) {\n      if (this.pathStarted) {\n        this.appendToBuffer(point, bufferSize);\n        this.updateSVGPath(bufferSize);\n      }\n    }\n  }, {\n    key: \"onPointerUp\",\n    value: function onPointerUp() {\n      if (this.pathStarted) {\n        this.pathStarted = false;\n      }\n    }\n  }, {\n    key: \"appendToBuffer\",\n    value: function appendToBuffer(point, bufferSize) {\n      this.buffer.push(point);\n\n      while (this.buffer.length > bufferSize) {\n        this.buffer.shift();\n      }\n    }\n  }, {\n    key: \"getAveragePoint\",\n    value: function getAveragePoint(offset, bufferSize) {\n      var len = this.buffer.length;\n\n      if (len % 2 === 1 || len >= bufferSize) {\n        var totalX = 0;\n        var totalY = 0;\n        var point = new DOMPoint();\n        var count = 0;\n\n        for (var i = offset; i < len; i++) {\n          count++;\n          point = this.buffer[i];\n          totalX += point.x;\n          totalY += point.y;\n        }\n\n        return new DOMPoint(totalX / count, totalY / count);\n      }\n\n      return null;\n    }\n  }, {\n    key: \"updateSVGPath\",\n    value: function updateSVGPath(bufferSize) {\n      var point = this.getAveragePoint(0, bufferSize);\n\n      if (point) {\n        this.strPath += ' L' + point.x + ' ' + point.y;\n        var tempPath = '';\n\n        for (var offset = 2; offset < this.buffer.length; offset += 2) {\n          point = this.getAveragePoint(offset, bufferSize);\n          tempPath += ' L' + point.x + ' ' + point.y;\n        }\n\n        this.path.setAttribute('d', this.strPath + tempPath);\n      }\n    }\n  }]);\n\n  return SVGDraw;\n}();",{"version":3,"sources":["/home/holwech/code/draw/src/draw/draw/SVGDraw.ts"],"names":[],"mappings":";;AAEA,WAAa,OAAb;AAAA;AAAA;AAOE,mBAAY,UAAZ,EAAgE;AAAA;;AALxD,SAAA,IAAA,GAAuB,QAAQ,CAAC,eAAT,CAAyB,4BAAzB,EAAuD,MAAvD,CAAvB;AACA,SAAA,WAAA,GAAc,KAAd;AAEA,SAAA,MAAA,GAAqB,EAArB;AAGN,SAAK,GAAL,GAAW,UAAX;AACD;;AATH;AAAA;AAAA,4BAWc;AACV,UAAI,SAAS,GAAG,KAAK,GAAL,CAAS,SAAzB;;AACA,aAAO,SAAP,EAAkB;AAChB,aAAK,GAAL,CAAS,WAAT,CAAqB,SAArB;AACA,QAAA,SAAS,GAAG,KAAK,GAAL,CAAS,SAArB;AACD;AACF;AAjBH;AAAA;AAAA,kCAmBuB,KAnBvB,EAmBwC,KAnBxC,EAmB2D;AACvD,WAAK,WAAL,GAAmB,IAAnB;AACA,WAAK,IAAL,GAAY,QAAQ,CAAC,eAAT,CAAyB,4BAAzB,EAAuD,MAAvD,CAAZ;AACA,WAAK,IAAL,CAAU,YAAV,CAAuB,MAAvB,EAA+B,MAA/B;AACA,WAAK,IAAL,CAAU,YAAV,CAAuB,QAAvB,EAAiC,KAAK,CAAC,KAAvC;AACA,WAAK,IAAL,CAAU,YAAV,CAAuB,cAAvB,EAAuC,MAAM,CAAC,KAAK,CAAC,KAAP,CAA7C,EALuD,CAMvD;AACA;;AACA,WAAK,MAAL,GAAc,EAAd;AACA,WAAK,cAAL,CAAoB,KAApB,EAA2B,KAAK,CAAC,UAAjC;AACA,WAAK,OAAL,GAAe,MAAM,KAAK,CAAC,CAAZ,GAAgB,GAAhB,GAAsB,KAAK,CAAC,CAA3C;AACA,WAAK,IAAL,CAAU,YAAV,CAAuB,GAAvB,EAA4B,KAAK,OAAjC;AACA,WAAK,GAAL,CAAS,WAAT,CAAqB,KAAK,IAA1B;AACD;AAhCH;AAAA;AAAA,kCAkCuB,KAlCvB,EAkCwC,UAlCxC,EAkC0D;AACtD,UAAI,KAAK,WAAT,EAAsB;AACpB,aAAK,cAAL,CAAoB,KAApB,EAA2B,UAA3B;AACA,aAAK,aAAL,CAAmB,UAAnB;AACD;AACF;AAvCH;AAAA;AAAA,kCAyCoB;AAChB,UAAI,KAAK,WAAT,EAAsB;AACpB,aAAK,WAAL,GAAmB,KAAnB;AACD;AACF;AA7CH;AAAA;AAAA,mCA+CyB,KA/CzB,EA+C0C,UA/C1C,EA+C4D;AACxD,WAAK,MAAL,CAAY,IAAZ,CAAiB,KAAjB;;AACA,aAAO,KAAK,MAAL,CAAY,MAAZ,GAAqB,UAA5B,EAAwC;AACtC,aAAK,MAAL,CAAY,KAAZ;AACD;AACF;AApDH;AAAA;AAAA,oCAsD0B,MAtD1B,EAsD0C,UAtD1C,EAsD4D;AACxD,UAAM,GAAG,GAAG,KAAK,MAAL,CAAY,MAAxB;;AACA,UAAI,GAAG,GAAG,CAAN,KAAY,CAAZ,IAAiB,GAAG,IAAI,UAA5B,EAAwC;AACtC,YAAI,MAAM,GAAG,CAAb;AACA,YAAI,MAAM,GAAG,CAAb;AACA,YAAI,KAAK,GAAa,IAAI,QAAJ,EAAtB;AACA,YAAI,KAAK,GAAG,CAAZ;;AACA,aAAK,IAAI,CAAC,GAAG,MAAb,EAAqB,CAAC,GAAG,GAAzB,EAA8B,CAAC,EAA/B,EAAmC;AACjC,UAAA,KAAK;AACL,UAAA,KAAK,GAAG,KAAK,MAAL,CAAY,CAAZ,CAAR;AACA,UAAA,MAAM,IAAI,KAAK,CAAC,CAAhB;AACA,UAAA,MAAM,IAAI,KAAK,CAAC,CAAhB;AACD;;AACD,eAAO,IAAI,QAAJ,CAAa,MAAM,GAAG,KAAtB,EAA6B,MAAM,GAAG,KAAtC,CAAP;AACD;;AACD,aAAO,IAAP;AACD;AAtEH;AAAA;AAAA,kCAwEwB,UAxExB,EAwE0C;AACtC,UAAI,KAAK,GAAoB,KAAK,eAAL,CAAqB,CAArB,EAAwB,UAAxB,CAA7B;;AACA,UAAI,KAAJ,EAAW;AACT,aAAK,OAAL,IAAgB,OAAO,KAAM,CAAC,CAAd,GAAkB,GAAlB,GAAwB,KAAM,CAAC,CAA/C;AACA,YAAI,QAAQ,GAAG,EAAf;;AACA,aAAK,IAAI,MAAM,GAAG,CAAlB,EAAqB,MAAM,GAAG,KAAK,MAAL,CAAY,MAA1C,EAAkD,MAAM,IAAI,CAA5D,EAA+D;AAC7D,UAAA,KAAK,GAAG,KAAK,eAAL,CAAqB,MAArB,EAA6B,UAA7B,CAAR;AACA,UAAA,QAAQ,IAAI,OAAO,KAAM,CAAC,CAAd,GAAkB,GAAlB,GAAwB,KAAM,CAAC,CAA3C;AACD;;AACD,aAAK,IAAL,CAAU,YAAV,CAAuB,GAAvB,EAA4B,KAAK,OAAL,GAAe,QAA3C;AACD;AACF;AAnFH;;AAAA;AAAA","sourcesContent":["import { IStrokeProps } from './../utils/interfaces';\n\nexport class SVGDraw {\n  private svg: HTMLElement & SVGElement & SVGSVGElement;\n  private path: SVGPathElement = document.createElementNS('http://www.w3.org/2000/svg', 'path');\n  private pathStarted = false;\n  private strPath!: string;\n  private buffer: DOMPoint[] = [];\n\n  constructor(svgElement: HTMLElement & SVGElement & SVGSVGElement) {\n    this.svg = svgElement;\n  }\n\n  public clear(): void {\n    let lastChild = this.svg.lastChild;\n    while (lastChild) {\n      this.svg.removeChild(lastChild);\n      lastChild = this.svg.lastChild;\n    }\n  }\n\n  public onPointerDown(point: DOMPoint, style: IStrokeProps): void {\n    this.pathStarted = true;\n    this.path = document.createElementNS('http://www.w3.org/2000/svg', 'path');\n    this.path.setAttribute('fill', 'none');\n    this.path.setAttribute('stroke', style.color);\n    this.path.setAttribute('stroke-width', String(style.width));\n    // Keeps stroke width constant, regardless of zoom\n    // this.path.setAttribute('vector-effect', 'non-scaling-stroke');\n    this.buffer = [];\n    this.appendToBuffer(point, style.bufferSize);\n    this.strPath = 'M' + point.x + ' ' + point.y;\n    this.path.setAttribute('d', this.strPath);\n    this.svg.appendChild(this.path);\n  }\n\n  public onPointerMove(point: DOMPoint, bufferSize: number): void {\n    if (this.pathStarted) {\n      this.appendToBuffer(point, bufferSize);\n      this.updateSVGPath(bufferSize);\n    }\n  }\n\n  public onPointerUp(): void {\n    if (this.pathStarted) {\n      this.pathStarted = false;\n    }\n  }\n\n  private appendToBuffer(point: DOMPoint, bufferSize: number): void {\n    this.buffer.push(point);\n    while (this.buffer.length > bufferSize) {\n      this.buffer.shift();\n    }\n  }\n\n  private getAveragePoint(offset: number, bufferSize: number): null | DOMPoint {\n    const len = this.buffer.length;\n    if (len % 2 === 1 || len >= bufferSize) {\n      let totalX = 0;\n      let totalY = 0;\n      let point: DOMPoint = new DOMPoint();\n      let count = 0;\n      for (let i = offset; i < len; i++) {\n        count++;\n        point = this.buffer[i];\n        totalX += point.x;\n        totalY += point.y;\n      }\n      return new DOMPoint(totalX / count, totalY / count);\n    }\n    return null;\n  }\n\n  private updateSVGPath(bufferSize: number): void {\n    let point: DOMPoint | null = this.getAveragePoint(0, bufferSize);\n    if (point) {\n      this.strPath += ' L' + point!.x + ' ' + point!.y;\n      let tempPath = '';\n      for (let offset = 2; offset < this.buffer.length; offset += 2) {\n        point = this.getAveragePoint(offset, bufferSize);\n        tempPath += ' L' + point!.x + ' ' + point!.y;\n      }\n      this.path.setAttribute('d', this.strPath + tempPath);\n    }\n  }\n\n}\n"],"sourceRoot":""}]}